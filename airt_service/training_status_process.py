# AUTOGENERATED! DO NOT EDIT! File to edit: ../notebooks/Training_Status_Process.ipynb.

# %% auto 0
__all__ = ['get_recent_event_for_user', 'get_count_from_training_data_ch_table', 'process_training_status']

# %% ../notebooks/Training_Status_Process.ipynb 2
import random
from datetime import datetime, timedelta
from os import environ
from time import sleep
from typing import *

import asyncio
from asyncer import asyncify
from sqlalchemy.exc import NoResultFound
from sqlmodel import Session, select, func

import airt_service
from .data.clickhouse import get_count
from .db.models import get_session_with_context, User, TrainingStreamStatus
from airt.logger import get_logger
from airt.patching import patch

# %% ../notebooks/Training_Status_Process.ipynb 5
logger = get_logger(__name__)

# %% ../notebooks/Training_Status_Process.ipynb 12
def get_recent_event_for_user(username: str) -> Optional[TrainingStreamStatus]:
    with get_session_with_context() as session:
        user = session.exec(select(User).where(User.username == username)).one()
        try:
            event = session.exec(
                select(TrainingStreamStatus)
                .where(TrainingStreamStatus.user == user)
                .order_by(TrainingStreamStatus.created.desc())  # type: ignore
                .order_by(TrainingStreamStatus.id.desc())  # type: ignore
                .limit(1)
            ).one()
        except NoResultFound:
            return None
    return event

# %% ../notebooks/Training_Status_Process.ipynb 14
def get_count_from_training_data_ch_table() -> int:
    return airt_service.data.clickhouse.get_count(
        username=environ["KAFKA_CH_USERNAME"],
        password=environ["KAFKA_CH_PASSWORD"],
        host=environ["KAFKA_CH_HOST"],
        port=int(environ["KAFKA_CH_PORT"]),
        database=environ["KAFKA_CH_DATABASE"],
        table=environ["KAFKA_CH_TABLE"],
        protocol=environ["KAFKA_CH_PROTOCOL"],
    )

# %% ../notebooks/Training_Status_Process.ipynb 16
@patch(cls_method=True)
def _create(
    cls: TrainingStreamStatus, *, event: str, count: int, user: User, session: Session
) -> TrainingStreamStatus:
    training_event = TrainingStreamStatus(event=event, count=count, user=user)
    session.add(training_event)
    session.commit()
    return training_event

# %% ../notebooks/Training_Status_Process.ipynb 17
async def process_training_status(username: str):
    # Get recent event for username
    prev_count = 0
    #     prev_check_on = datetime.utcnow()
    while True:
        recent_event = await asyncify(get_recent_event_for_user)(username)
        logger.info(f"{recent_event=}")
        if recent_event is None:
            pass
        elif recent_event.event == "end":
            # Check model training status started and start it if not already
            pass
        elif recent_event.event in ["start", "upload"]:
            curr_count = await asyncify(get_count_from_training_data_ch_table)()
            curr_check_on = datetime.utcnow()

            with get_session_with_context() as session:
                user = session.exec(select(User).where(User.username == username)).one()
                if (
                    curr_count == prev_count
                    and curr_check_on - recent_event.created > timedelta(seconds=10)
                ):
                    end_event = await asyncify(TrainingStreamStatus._create)(
                        event="end", count=curr_count, user=user, session=session
                    )
                    prev_count = 0
                    # Start model training status
                elif curr_count != prev_count:
                    upload_event = await asyncify(TrainingStreamStatus._create)(
                        event="upload", count=curr_count, user=user, session=session
                    )
                    prev_count = curr_count
        #                 prev_check_on = curr_check_on

        sleep(random.randint(1, 2))
