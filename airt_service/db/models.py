# AUTOGENERATED! DO NOT EDIT! File to edit: ../../notebooks/DB_Models.ipynb.

# %% auto 0
__all__ = ['SubscriptionType', 'UserBase', 'User', 'UserCreate', 'UserRead', 'TrainingEvent', 'TrainingStreamStatus',
           'APIKeyBase', 'APIKey', 'APIKeyCreate', 'APIKeyRead', 'DataBlobTagLink', 'DataSourceTagLink', 'TagBase',
           'Tag', 'TagCreate', 'TagRead', 'CloudProvider', 'DataBlobBase', 'DataBlob', 'DataBlobRead', 'DataBlobSelect',
           'DataSourceBase', 'DataSource', 'DataSourceRead', 'DataSourceSelect', 'ModelBase', 'Model', 'ModelRead',
           'PredictionBase', 'Prediction', 'PredictionRead', 'PredictionPushBase', 'PredictionPush',
           'PredictionPushRead', 'SSOProvider', 'SSOBase', 'SSO', 'SSORead', 'SSOProtocol', 'SMS', 'SMSProtocol',
           'get_db_params_from_env_vars', 'create_connection_string', 'get_engine', 'check_db_is_up', 'get_session',
           'get_session_with_context', 'create_user_for_testing', 'create_initial_users']

# %% ../../notebooks/DB_Models.ipynb 3
import enum
import random
import string
import time
import uuid as uuid_pkg
from contextlib import contextmanager
from datetime import datetime, timedelta
from os import environ
from pathlib import Path
from typing import *
from urllib.parse import quote_plus as urlquote

import sqlalchemy
from pydantic import EmailStr, validator
from sqlalchemy.exc import NoResultFound, IntegrityError
from sqlalchemy.future.engine import Engine
from fastapi import BackgroundTasks

from sqlmodel import (
    Field,
    Relationship,
    Session,
    SQLModel,
    create_engine,
    select,
    Column,
    VARCHAR,
    TEXT,
    Enum,
)
from sqlmodel.sql.sqltypes import GUID
from sqlalchemy.engine.interfaces import Dialect

from airt.logger import get_logger
from airt.patching import patch

# from airt_service.data.tag import Tag
from ..sanitizer import sanitized_print
from ..helpers import get_password_hash

# %% ../../notebooks/DB_Models.ipynb 4
logger = get_logger(__name__)

# %% ../../notebooks/DB_Models.ipynb 6
class SubscriptionType(str, enum.Enum):
    """A base class for managing the subscription types"""

    small = "small"
    medium = "medium"
    large = "large"
    infobip = "infobip"
    captn = "captn"
    test = "test"
    superuser = "superuser"


class UserBase(SQLModel):
    """A base class for managing the users"""

    username: str = Field(sa_column=Column("username", VARCHAR(100), unique=True))
    first_name: str
    last_name: str
    email: EmailStr = Field(sa_column=Column("email", VARCHAR(100), unique=True))
    subscription_type: SubscriptionType = Field(
        sa_column=Column(Enum(SubscriptionType))
    )
    super_user: bool = False
    phone_number: str = Field(
        sa_column=Column("phone_number", VARCHAR(15)), default=None
    )


class User(UserBase, table=True):
    """A subclass of UserBase class"""

    __table_args__ = {"extend_existing": True}

    id: Optional[int] = Field(default=None, primary_key=True)
    uuid: uuid_pkg.UUID = Field(
        default_factory=uuid_pkg.uuid4, index=True, nullable=False
    )
    password: str
    disabled: bool = False
    mfa_secret: Optional[str] = Field(default=None)
    is_mfa_active: bool = Field(default=False, nullable=False)
    created: datetime = Field(sa_column_kwargs={"default": datetime.utcnow})
    is_phone_number_verified: Optional[bool] = False

    apikeys: List["APIKey"] = Relationship(back_populates="user")
    training_stream_statuses: List["TrainingStreamStatus"] = Relationship(
        back_populates="user"
    )
    datablobs: List["DataBlob"] = Relationship(back_populates="user")
    datasources: List["DataSource"] = Relationship(back_populates="user")
    models: List["Model"] = Relationship(back_populates="user")
    ssos: List["SSO"] = Relationship(back_populates="user")
    smss: List["SMS"] = Relationship(back_populates="user")

    def __repr__(self):
        """Return custom string representation of the User class objects"""
        return (
            f"User(id={repr(self.id)}, uuid={repr(self.uuid)}, username={repr(self.username)}, first_name={repr(self.first_name)}, last_name={repr(self.last_name)}, "
            f"email={repr(self.email)}, subscription_type={repr(self.subscription_type)}, super_user={repr(self.super_user)}, "
            f"disabled={repr(self.disabled)}, created={repr(self.created)}, "
            f"phone_number={repr(self.phone_number)}, is_phone_number_verified={repr(self.is_phone_number_verified)}, "
            f"mfa_secret={'*'*len(repr(self.mfa_secret))}, is_mfa_active={repr(self.is_mfa_active)})"
        )

    @classmethod
    def get(cls, id: int, session: Session) -> "User":
        """Function to get user object based on given user id

        Args:
            id: User id
            session: Sqlmodel session

        Returns:
            A user object for given id

        Raises:
            HTTPException: if id does not exists in database
        """
        raise NotImplementedError()

    @classmethod
    def check_username_exists(cls, username: str, session: Session):
        """Check given username already exists in database or not

        Args:
            username: Username to check
            session: Sqlmodel session

        Raises:
            HTTPException: if username exists
        """
        raise NotImplementedError()

    @classmethod
    def check_email_exists(cls, email: str, session: Session):
        """Check given email already exists in database or not

        Args:
            email: Email to check
            session: Sqlmodel session

        Raises:
            HTTPException: if email is an invalid one or if email exists
        """
        raise NotImplementedError()

    def disable(self, session: Session) -> "User":
        """Disable user

        Args:
            session: Sqlmodel session

        Returns:
            The disabled user object

        Raises:
            HTTPException: if user is already disabled
        """
        raise NotImplementedError()

    def enable(self, session: Session) -> "User":
        """Enable user

        Args:
            session: Sqlmodel session

        Returns:
            The enabled user object
        """
        raise NotImplementedError()

    @classmethod
    def get_all(
        cls,
        disabled: bool,
        offset: int,
        limit: int,
        session: Session,
    ) -> List["User"]:
        """Function to get all users

        Args:
            disabled: Whether to get only disabled users
            offset: Offset results by given integer
            limit: Limit results by given integer
            session: Sqlmodel session

        Returns:
            a list of user objects
        """
        raise NotImplementedError()


class UserCreate(UserBase):
    """A class for creating new users"""

    password: str
    otp: Optional[str] = None


class UserRead(UserBase):
    """A class to create the User object

    It is used as response model for multiple /user/* routes
    """

    uuid: uuid_pkg.UUID
    disabled: bool
    created: datetime
    is_phone_number_verified: Optional[bool] = False
    is_mfa_active: bool

# %% ../../notebooks/DB_Models.ipynb 7
class TrainingEvent(str, enum.Enum):
    """Enum class for training data events"""

    start = "start"
    upload = "upload"
    end = "end"


class TrainingStreamStatus(SQLModel, table=True):
    """Model to keep track of TrainingStreamStatus"""

    __table_args__ = {"extend_existing": True}

    id: Optional[int] = Field(default=None, primary_key=True)
    uuid: uuid_pkg.UUID = Field(
        default_factory=uuid_pkg.uuid4, index=True, nullable=False
    )
    account_id: int
    application_id: Optional[str] = Field(default=None, nullable=True)
    model_id: str
    model_type: str
    event: TrainingEvent = Field(sa_column=Column(Enum(TrainingEvent)), nullable=False)
    count: int
    total: int
    created: datetime = Field(sa_column_kwargs={"default": datetime.utcnow})

    user_id: int = Field(default=None, foreign_key="user.id", nullable=False)
    user: User = Relationship(back_populates="training_stream_statuses")

    @classmethod
    def _create(
        cls, *, event: str, count: int, user: User, session: Session
    ) -> "TrainingStreamStatus":
        raise NotImplementedError()

# %% ../../notebooks/DB_Models.ipynb 8
class APIKeyBase(SQLModel):
    """A base class for managing the API keys"""

    name: Optional[str]
    expiry: Optional[datetime]


class APIKey(APIKeyBase, table=True):
    """A subclass of APIKeyBase class"""

    __table_args__ = {"extend_existing": True}

    id: Optional[int] = Field(default=None, primary_key=True)
    uuid: uuid_pkg.UUID = Field(
        default_factory=uuid_pkg.uuid4, index=True, nullable=False
    )
    disabled: bool = False
    created: datetime = Field(sa_column_kwargs={"default": datetime.utcnow})

    user_id: int = Field(default=None, foreign_key="user.id")
    user: User = Relationship(back_populates="apikeys")

    @classmethod
    def get_all(
        cls,
        user: User,
        include_disabled: bool,
        offset: int,
        limit: int,
        session: Session,
    ) -> List["APIKey"]:
        """Get all apikeys

        Args:
            user: User object
            include_disabled: Whether to include disabled apikeys
            offset: offset Results by given integer
            limit: limit Results by given integer
            session: Sqlmodel session

        Returns:
            A list of apikey objects
        """
        raise NotImplementedError()


class APIKeyCreate(APIKeyBase):
    """A class to create a new apikey"""

    otp: Optional[str] = None


class APIKeyRead(APIKeyBase):
    """A class to create the APIKey object

    It is used as a response model for multiple /apikey/* routes
    """

    uuid: uuid_pkg.UUID
    disabled: bool
    created: datetime

# %% ../../notebooks/DB_Models.ipynb 9
class DataBlobTagLink(SQLModel, table=True):
    __table_args__ = {"extend_existing": True}

    datablob_id: Optional[int] = Field(
        default=None, foreign_key="datablob.id", primary_key=True
    )
    tag_id: Optional[int] = Field(default=None, foreign_key="tag.id", primary_key=True)

# %% ../../notebooks/DB_Models.ipynb 10
class DataSourceTagLink(SQLModel, table=True):
    __table_args__ = {"extend_existing": True}

    datasource_id: Optional[int] = Field(
        default=None, foreign_key="datasource.id", primary_key=True
    )
    tag_id: Optional[int] = Field(default=None, foreign_key="tag.id", primary_key=True)

# %% ../../notebooks/DB_Models.ipynb 11
class TagBase(SQLModel):
    """A base class for managing the tags"""

    name: str = Field(sa_column=Column("name", VARCHAR(100), unique=True))


class Tag(TagBase, table=True):
    """A subclass of TagBase class"""

    __table_args__ = {"extend_existing": True}

    id: Optional[int] = Field(default=None, primary_key=True)
    uuid: uuid_pkg.UUID = Field(
        default_factory=uuid_pkg.uuid4, index=True, nullable=False
    )
    created: datetime = Field(sa_column_kwargs={"default": datetime.utcnow})
    datablobs: List["DataBlob"] = Relationship(
        back_populates="tags", link_model=DataBlobTagLink
    )
    datasources: List["DataSource"] = Relationship(
        back_populates="tags", link_model=DataSourceTagLink
    )

    @classmethod
    def get_by_name(cls, name: str, session: Session) -> "Tag":
        """Get tag object for given name

        Creates and returns the tag object if the tag_name does not exist in the database

        Args:
            name: tag name to get tag object
            session: sqlmodel session

        Returns:
            The tag object for the given tag name
        """
        raise NotImplementedError()


class TagCreate(TagBase):
    """A class for creating and assigning tags to a DataSource/DataBlob"""


class TagRead(TagBase):
    """A class to create the TagRead object

    It is used in the response model for multiple /datablob/* and /datasource/* routes
    """

    uuid: uuid_pkg.UUID
    created: datetime

# %% ../../notebooks/DB_Models.ipynb 12
class CloudProvider(str, enum.Enum):
    """A base class for managing different cloud providers"""

    aws = "aws"
    azure = "azure"

# %% ../../notebooks/DB_Models.ipynb 13
class DataBlobBase(SQLModel):
    """A base class for managing the datablob"""

    type: str
    total_steps: int
    source: str
    completed_steps: int = 0
    folder_size: Optional[int] = None
    error: Optional[str] = None
    cloud_provider: CloudProvider = Field(sa_column=Column(Enum(CloudProvider)))
    region: str
    disabled: bool = False
    created: datetime = Field(sa_column_kwargs={"default": datetime.utcnow})
    pulled_on: Optional[datetime] = None


class DataBlob(DataBlobBase, table=True):
    """A subclass of DataBlobBase class"""

    __table_args__ = {"extend_existing": True}

    id: Optional[int] = Field(default=None, primary_key=True)
    uuid: uuid_pkg.UUID = Field(
        default_factory=uuid_pkg.uuid4, index=True, nullable=False
    )
    uri: Optional[str]
    path: Optional[Path] = None
    user_id: int = Field(default=None, foreign_key="user.id")
    user: User = Relationship(back_populates="datablobs")
    datasources: List["DataSource"] = Relationship(back_populates="datablob")
    tags: List[Tag] = Relationship(
        back_populates="datablobs", link_model=DataBlobTagLink
    )

    def __repr__(self):
        """Return custom string representation of the DataBlob class objects"""
        return (
            f"DataBlob(id={repr(self.id)}, uuid={repr(self.uuid)}, type={repr(self.type)}, uri={repr(self.uri)}, source={repr(self.source)}, "
            f"total_steps={repr(self.total_steps)}, completed_steps={repr(self.completed_steps)}, "
            f"folder_size={repr(self.folder_size)}, cloud_provider={repr(self.cloud_provider)}, region={repr(self.region)}, "
            f"error={repr(self.error)}, disabled={repr(self.disabled)}, path={repr(self.path)}, "
            f"created={repr(self.created)}, user_id={repr(self.user_id)}, pulled_on={repr(self.pulled_on)}, "
            f"tags={repr(self.tags)}"
            f")"
        )

    @classmethod
    def from_clickhouse(
        cls,
        *,
        from_clickhouse_request: "FromClickHouseRequest",  # type: ignore
        user: User,
        session: Session,
        background_tasks: BackgroundTasks,
    ) -> "DataBlob":
        """Create a datablob from a clickhouse database

        Args:
            from_clickhouse_request: The from_clickhouse request
            user: User object
            session: Sqlmodel session
            background_tasks: BackgroundTasks object

        Returns:
            A new datablob created from a clickhouse database
        """
        raise NotImplementedError()

    @classmethod
    def from_s3(
        cls,
        *,
        from_s3_request: "FromS3Request",  # type: ignore
        user: User,
        session: Session,
        background_tasks: BackgroundTasks,
        no_retries: int = 3,
    ) -> "DataBlob":
        """Retrieves data from an S3 bucket

        Args:
            from_s3_request: The from_s3 request
            user: User object
            session: Sqlmodel session
            background_tasks: BackgroundTasks object
            no_retries: retry count

        Returns:
            A new datablob created from a RDBMS
        """
        raise NotImplementedError()

    @classmethod
    def from_rdbms(
        cls,
        *,
        from_db_request: "FromDBRequest",  # type: ignore
        database_server: str,
        user: User,
        session: Session,
        background_tasks: BackgroundTasks,
    ) -> "DataBlob":
        """Create a datablob from a RDBMS

        Args:
            from_db_request: The from_db request
            database_server: Database engine name
            user: User object
            session: Sqlmodel session
            background_tasks: BackgroundTasks object

        Returns:
            A new datablob created from a RDBMS
        """
        raise NotImplementedError()

    @classmethod
    def from_local(
        cls,
        *,
        path: str,
        user_tag: Optional[str] = None,
        user: User,
        session: Session,
    ) -> "FromLocalResponse":  # type: ignore
        """Create a datablob from local file(s)

        Args:
            path: The relative or absolute path to a local file or to a directory containing the files.
            user_tag: A string to tag the datablob
            user: User object
            session: Sqlmodel session

        Returns:
            A new datablob created from local file(s)
        """
        raise NotImplementedError()

    @classmethod
    def get_all(
        cls,
        disabled: bool,
        completed: bool,
        offset: int,
        limit: int,
        user: User,
        session: Session,
    ) -> List["DataBlob"]:
        """Get all datablobs created by the user

        Args:
            disabled: Whether to get disabled datablobs
            completed: Whether to include only datablobs which are successfully pulled from its source
            offset: Offset results by given integer
            limit: Limit results by given integer
            user: User object
            session: Sqlmodel session

        Returns:
            A list of datablob objects
        """
        raise NotImplementedError()


class DataBlobRead(DataBlobBase):
    """A class to create the DataBlob object

    It is used as response model for multiple /data/* routes
    """

    uuid: uuid_pkg.UUID
    user: uuid_pkg.UUID
    datasources: List[uuid_pkg.UUID]
    tags: List[TagRead]

    # Reference: https://github.com/tiangolo/sqlmodel/issues/77
    @validator("datasources", pre=True)
    @classmethod
    def get_datasources_uuid(cls, datasources: DataBlobBase) -> List[uuid_pkg.UUID]:
        return [ds.uuid for ds in datasources]  # type: ignore

    @validator("user", pre=True)
    @classmethod
    def get_user_uuid(cls, user: User) -> uuid_pkg.UUID:
        return user.uuid


class DataBlobSelect(SQLModel):
    """A class for handling multiple routes for handling the DataBlob object"""

    data_id: int

# %% ../../notebooks/DB_Models.ipynb 14
class DataSourceBase(SQLModel):
    """A base class for managing the datasource"""

    hash: Optional[str] = None
    total_steps: int
    completed_steps: int = 0
    folder_size: Optional[int] = None
    no_of_rows: Optional[int] = None
    error: Optional[str] = None
    cloud_provider: CloudProvider = Field(sa_column=Column(Enum(CloudProvider)))
    region: str
    disabled: bool = False
    created: datetime = Field(sa_column_kwargs={"default": datetime.utcnow})
    pulled_on: Optional[datetime] = None


class DataSource(DataSourceBase, table=True):
    """A subclass of DataSourceBase class"""

    __table_args__ = {"extend_existing": True}

    id: Optional[int] = Field(default=None, primary_key=True)
    uuid: uuid_pkg.UUID = Field(
        default_factory=uuid_pkg.uuid4, index=True, nullable=False
    )
    datablob_id: int = Field(default=None, foreign_key="datablob.id")
    datablob: DataBlob = Relationship(back_populates="datasources")
    path: Optional[Path] = None

    user_id: int = Field(default=None, foreign_key="user.id")
    user: User = Relationship(back_populates="datasources")
    model: "Model" = Relationship(back_populates="datasource")
    prediction: "Prediction" = Relationship(back_populates="datasource")
    tags: List[Tag] = Relationship(
        back_populates="datasources", link_model=DataSourceTagLink
    )

    def __repr__(self):
        """Return custom string representation of the DataSource class objects"""
        return (
            f"DataSource(id={repr(self.id)}, uuid={repr(self.uuid)}, hash={repr(self.hash)}, "
            f"total_steps={repr(self.total_steps)}, completed_steps={repr(self.completed_steps)}, "
            f"folder_size={repr(self.folder_size)}, no_of_rows={repr(self.no_of_rows)}, "
            f"cloud_provider={repr(self.cloud_provider)}, region={repr(self.region)}, "
            f"error={repr(self.error)}, disabled={repr(self.disabled)}, path={repr(self.path)}, "
            f"created={repr(self.created)}, user_id={repr(self.user_id)}, pulled_on={repr(self.pulled_on)}, "
            f"tags={repr(self.tags)}"
            f")"
        )

    @classmethod
    def get_all(
        cls,
        disabled: bool,
        completed: bool,
        offset: int,
        limit: int,
        user: User,
        session: Session,
    ) -> List["DataSource"]:
        """Get all datasources created by the user

        Args:
            disabled: Whether to get disabled datasources
            completed: Whether to include only datasources which are pulled from its source
            offset: Offset results by given integer
            limit: Limit results by given integer
            user: User object
            session: Sqlmodel session

        Returns:
            A list of datasource objects
        """
        raise NotImplementedError()


class DataSourceRead(DataSourceBase):
    """A class to create the DataSource object

    It can be used as response model for multiple /data/* routes
    """

    uuid: uuid_pkg.UUID
    user: uuid_pkg.UUID
    datablob: uuid_pkg.UUID
    tags: List[TagRead]

    @validator("datablob", pre=True)
    @classmethod
    def get_datablob_uuid(cls, datablob: DataBlob) -> uuid_pkg.UUID:
        return datablob.uuid

    @validator("user", pre=True)
    @classmethod
    def get_user_uuid(cls, user: User) -> uuid_pkg.UUID:
        return user.uuid


class DataSourceSelect(SQLModel):
    """Request DataSource Object for multiple routes"""

    data_uuid: uuid_pkg.UUID

# %% ../../notebooks/DB_Models.ipynb 15
DataBlobRead.update_forward_refs()
DataSourceRead.update_forward_refs()

# %% ../../notebooks/DB_Models.ipynb 16
class ModelBase(SQLModel):
    """A base class for managing the model"""

    client_column: str
    target_column: str
    target: str
    predict_after: timedelta
    timestamp_column: Optional[str] = None
    total_steps: int
    completed_steps: int = 0
    error: Optional[str] = None
    cloud_provider: CloudProvider = Field(sa_column=Column(Enum(CloudProvider)))
    region: str
    disabled: bool = False
    created: datetime = Field(sa_column_kwargs={"default": datetime.utcnow})


class Model(ModelBase, table=True):
    """A subclass of ModelBase class"""

    __table_args__ = {"extend_existing": True}

    id: Optional[int] = Field(default=None, primary_key=True)
    uuid: uuid_pkg.UUID = Field(
        default_factory=uuid_pkg.uuid4, index=True, nullable=False
    )
    path: Optional[Path] = None
    datasource_id: int = Field(default=None, foreign_key="datasource.id")
    datasource: DataSource = Relationship(back_populates="model")

    user_id: int = Field(default=None, foreign_key="user.id")
    user: User = Relationship(back_populates="models")

    predictions: List["Prediction"] = Relationship(back_populates="model")


class ModelRead(ModelBase):
    """A class to create the Model object

    It can be used as response model for multiple /model/* routes
    """

    uuid: uuid_pkg.UUID
    user: uuid_pkg.UUID
    datasource: uuid_pkg.UUID

    @validator("datasource", pre=True)
    @classmethod
    def get_datasource_uuid(cls, datasource: DataSource) -> uuid_pkg.UUID:
        return datasource.uuid

    @validator("user", pre=True)
    @classmethod
    def get_user_uuid(cls, user: User) -> uuid_pkg.UUID:
        return user.uuid

# %% ../../notebooks/DB_Models.ipynb 17
class PredictionBase(SQLModel):
    """A base class for managing the prediction"""

    total_steps: int
    completed_steps: int = 0
    error: Optional[str] = None
    cloud_provider: CloudProvider = Field(sa_column=Column(Enum(CloudProvider)))
    region: str
    disabled: bool = False
    created: datetime = Field(sa_column_kwargs={"default": datetime.utcnow})


class Prediction(PredictionBase, table=True):
    """A subclass of PredictionBase class"""

    __table_args__ = {"extend_existing": True}

    id: Optional[int] = Field(default=None, primary_key=True)
    uuid: uuid_pkg.UUID = Field(
        default_factory=uuid_pkg.uuid4, index=True, nullable=False
    )
    path: Optional[Path] = None
    datasource_id: int = Field(default=None, foreign_key="datasource.id")
    datasource: DataSource = Relationship(back_populates="prediction")
    model_id: int = Field(default=None, foreign_key="model.id")
    model: Model = Relationship(back_populates="predictions")
    prediction_pushes: List["PredictionPush"] = Relationship(
        back_populates="prediction"
    )

    @classmethod
    def get(cls, id: int, user: User, session: Session) -> "Prediction":
        """Get prediction object for given prediction id

        Args:
            id: Id of prediction
            user: User object
            session: Sqlmodel session
        Returns:
            The prediction object for given prediction id
        """
        raise NotImplementedError()

    def to_local(
        self,
        session: Session,
    ) -> Dict[str, str]:
        """Download prediction results to local

        Args:
            session: Session object

        Returns:
            The Download url of the prediction as a dict
        """
        raise NotImplementedError()

    def to_s3(
        self,
        s3_request: "S3Request",  # type: ignore
        session: Session,
        background_tasks: BackgroundTasks,
    ) -> "PredictionPush":
        """Push prediction reslults to S3

        Args:
            s3_request: S3Request object
            session: session

        Returns:
            An object of PredictionPush
        """
        raise NotImplementedError()

    def to_rdbms(
        self,
        db_request: "DBRequest",  # type: ignore
        database_server: str,
        session: Session,
        background_tasks: BackgroundTasks,
    ) -> "PredictionPush":
        """Push prediction resluts to a relational database

        Args:
            db_request: DBRequest object
            database_server: Database server to push the results
            session: Session object

        Returns:
            An object of PredictionPush
        """
        raise NotImplementedError()

    def to_clickhouse(
        self,
        clickhouse_request: "ClickHouseRequest",  # type: ignore
        session: Session,
        background_tasks: BackgroundTasks,
    ) -> "PredictionPush":
        """Push prediction results to a clickhouse database

        Args:
            clickhouse_request: ClickHouseRequest object
            session: Session object
            background_tasks: BackgroundTasks object

        Returns:
            An object of PredictionPush
        """
        raise NotImplementedError()


class PredictionRead(PredictionBase):
    """A class to create the Prediction Object

    It can be used as response model for multiple /prediction/* routes
    """

    uuid: uuid_pkg.UUID
    datasource: uuid_pkg.UUID
    model: uuid_pkg.UUID

    @validator("datasource", pre=True)
    @classmethod
    def get_datasource_uuid(cls, datasource: DataSource) -> uuid_pkg.UUID:
        return datasource.uuid

    @validator("model", pre=True)
    @classmethod
    def get_model_uuid(cls, model: Model) -> uuid_pkg.UUID:
        return model.uuid

# %% ../../notebooks/DB_Models.ipynb 18
class PredictionPushBase(SQLModel):
    """A base class for managing the prediction push"""

    total_steps: int
    completed_steps: int = 0
    error: Optional[str] = None
    created: datetime = Field(sa_column_kwargs={"default": datetime.utcnow})


class PredictionPush(PredictionPushBase, table=True):
    """A subclass of PredictionPushBase class"""

    __table_args__ = {"extend_existing": True}

    id: Optional[int] = Field(default=None, primary_key=True)
    uuid: uuid_pkg.UUID = Field(
        default_factory=uuid_pkg.uuid4, index=True, nullable=False
    )
    uri: str

    prediction_id: int = Field(default=None, foreign_key="prediction.id")
    prediction: Prediction = Relationship(back_populates="prediction_pushes")

    def __repr__(self):
        """Return custom string representation of the PredictionPush class objects"""
        return (
            f"PredictionPush(id={repr(self.id)}, uuid={repr(self.uuid)}, uri={repr(self.uri)}, "
            f"total_steps={repr(self.total_steps)}, completed_steps={repr(self.completed_steps)}, "
            f"error={repr(self.error)}, created={repr(self.created)}, prediction_id={repr(self.prediction_id)}, "
            f")"
        )


class PredictionPushRead(PredictionPushBase):
    """A class to create the Prediction push object

    It can be used as response model for multiple /prediction/push/* routes
    """

    uuid: uuid_pkg.UUID
    prediction: uuid_pkg.UUID

    @validator("prediction", pre=True)
    @classmethod
    def get_prediction_uuid(cls, prediction: Prediction) -> uuid_pkg.UUID:
        return prediction.uuid

# %% ../../notebooks/DB_Models.ipynb 19
class SSOProvider(str, enum.Enum):
    """A base class for managing the SSO providers"""

    google = "google"
    github = "github"


class SSOBase(SQLModel):
    """A base class for managing the sso"""

    sso_provider: SSOProvider = Field(sa_column=Column(Enum(SSOProvider)))
    sso_email: EmailStr = Field(
        sa_column=Column("sso_email", VARCHAR(100)), default=None
    )
    disabled: bool = False


class SSO(SSOBase, table=True):
    """A subclass of SSOBase class"""

    __table_args__ = {"extend_existing": True}

    id: Optional[int] = Field(default=None, primary_key=True)

    username: str = Field(default=None, foreign_key="user.username")
    user: User = Relationship(back_populates="ssos")

    ssoprotocols: List["SSOProtocol"] = Relationship(back_populates="sso")


class SSORead(SSOBase):
    """A subclass of SSOBase class

    It can be used as response model for /user/sso/* routes
    """


class SSOProtocol(SQLModel, table=True):
    """A base class for managing SSO protocol"""

    __table_args__ = {"extend_existing": True}

    id: Optional[int] = Field(default=None, primary_key=True)

    nonce: Optional[str] = Field(default=None)
    created_at: datetime = Field(sa_column_kwargs={"default": datetime.utcnow})
    is_sso_successful: bool = False
    error: Optional[str] = None

    sso_id: int = Field(default=None, foreign_key="sso.id")
    sso: SSO = Relationship(back_populates="ssoprotocols")

# %% ../../notebooks/DB_Models.ipynb 20
class SMS(SQLModel, table=True):
    """A base class for managing the sms"""

    __table_args__ = {"extend_existing": True}

    id: Optional[int] = Field(default=None, primary_key=True)
    application_id: str
    message_id: str

    user_id: int = Field(default=None, foreign_key="user.id")
    user: User = Relationship(back_populates="smss")
    smsprotocols: List["SMSProtocol"] = Relationship(back_populates="sms")


class SMSProtocol(SQLModel, table=True):
    """A base class for managing SMS protocol"""

    __table_args__ = {"extend_existing": True}

    id: Optional[int] = Field(default=None, primary_key=True)
    pin_id: str
    number_lookup_status: str
    sent_sms_status: str
    phone_number: str
    pin_verified: bool = False
    pin_attempts_remaining: Optional[int] = None

    sms_id: int = Field(default=None, foreign_key="sms.id")
    sms: SMS = Relationship(back_populates="smsprotocols")

# %% ../../notebooks/DB_Models.ipynb 21
def get_db_params_from_env_vars() -> Dict[str, Union[str, int]]:
    """Get db connection params from environment variables

    Returns:
        The dictionary of db connection params
    """
    return dict(
        username=environ["DB_USERNAME"],
        password=environ["DB_PASSWORD"],
        host=environ["DB_HOST"],
        port=int(environ["DB_PORT"]),
        database=environ["DB_DATABASE"],
        database_server=environ["DB_DATABASE_SERVER"],
    )

# %% ../../notebooks/DB_Models.ipynb 23
def create_connection_string(
    username: str,
    password: str,
    host: str,
    port: int,
    database: str,
    database_server: str,
) -> str:
    """Create db connection string from db connection params

    Args:
        username: DB username
        password: DB password
        host: DB host
        port: DB port
        database: Database to use
        database_server: Server/Engine of database
    Returns:
        The DB connection string
    """
    quoted_password = urlquote(password)
    conn_str = (
        f"{database_server}://{username}:{quoted_password}@{host}:{port}/{database}"
    )
    return conn_str

# %% ../../notebooks/DB_Models.ipynb 25
def get_engine(
    username: str,
    password: str,
    host: str,
    port: int,
    database: str,
    database_server: str,
    echo: bool = False,
) -> Engine:
    """Get sqlmodel engine for the given DB params

    Args:
        username: DB username
        password: DB password
        host: DB host
        port: DB port
        database: Database to use
        database_server: Server/Engine of database
        echo: Whether to print sqlmodel queries to db or not

    Returns:
        The sqlmodel engine created from db connection params
    """
    conn_str = create_connection_string(
        username=username,
        password=password,
        host=host,
        port=port,
        database=database,
        database_server=database_server,
    )
    engine = create_engine(conn_str, echo=echo)
    return engine

# %% ../../notebooks/DB_Models.ipynb 27
def check_db_is_up():
    """Function to check whether DB is up and running or not"""
    # Based on - https://github.com/CTFd/CTFd/issues/725#issuecomment-814379242
    logger.info(f"Waiting for db to be up and running")
    conn_str = create_connection_string(**get_db_params_from_env_vars())
    sleep_for = 10
    while True:
        try:
            logger.info("Checking connection")
            sqlalchemy.create_engine(conn_str).raw_connection().ping()
            logger.info("Connection established")
            break
        except Exception as e:
            logger.error(f"Error - {str(e)}")
            logger.error(
                f"Connection could not be established, sleeping for {sleep_for} seconds"
            )
            time.sleep(sleep_for)
    logger.info(f"DB is up and running")

# %% ../../notebooks/DB_Models.ipynb 29
def get_session():
    """Get DB session without context manager

    Yields:
        session: SQLmodel session
    """
    engine = get_engine(**get_db_params_from_env_vars())
    with Session(engine) as session:
        yield session
    engine.dispose()

# %% ../../notebooks/DB_Models.ipynb 31
@contextmanager
def get_session_with_context():
    """Get DB session with context manager

    Yields:
        session: SQLmodel session
    """
    iter_session = iter(get_session())
    session = next(iter_session)
    yield session
    next(iter_session, "close session")

# %% ../../notebooks/DB_Models.ipynb 33
def create_user_for_testing(
    username: Optional[str] = None, subscription_type: str = "test"
) -> str:
    """Create users for testing purposes

    Args:
        subscription_type: Subscription type of user

    Returns:
        The username of created user
    """
    if username is None:
        username = "".join(
            random.choice(string.ascii_lowercase) for _ in range(10)  # nosec B311
        )

    with get_session_with_context() as session:
        try:
            user = User(
                username=username,
                password=get_password_hash(environ["AIRT_SERVICE_SUPER_USER_PASSWORD"]),
                first_name="unittest",
                last_name="user",
                email=f"{username}@email.com",
                subscription_type=subscription_type,
            )
            session.add(user)
            session.commit()
        except IntegrityError:
            pass
    return username

# %% ../../notebooks/DB_Models.ipynb 35
@patch(cls_method=True)
def get_by_name(cls: Tag, name: str, session: Session) -> Tag:
    """Get tag object for given name

    Creates and returns the tag object if the tag_name does not exist in the database

    Args:
        name: tag name to get tag object
        session: sqlmodel session

    Returns:
        The tag object for the given tag name
    """
    try:
        tag = session.exec(select(Tag).where(Tag.name == name)).one()
    except NoResultFound:
        try:
            tag = Tag(name=name)
            session.add(tag)
            session.commit()
        except IntegrityError:
            session.rollback()
            tag = Tag.get_by_name(name=name, session=session)  # type: ignore
    return tag

# %% ../../notebooks/DB_Models.ipynb 37
users_to_create = [
    {
        "username": "johndoe",
        "first_name": "John",
        "last_name": "Doe",
        "email": "johndoe@airt.ai",
        "subscription_type": "small",
        "super_user": False,
        "disabled": False,
    },
    {
        "username": "davor",
        "first_name": "Davor",
        "last_name": "Runje",
        "email": "davor@airt.ai",
        "subscription_type": "superuser",
        "super_user": True,
        "disabled": False,
    },
    {
        "username": "kumaran",
        "first_name": "Kumaran",
        "last_name": "Rajendhiran",
        "email": "kumaran@airt.ai",
        "subscription_type": "superuser",
        "super_user": True,
        "disabled": False,
    },
]

# %% ../../notebooks/DB_Models.ipynb 38
def create_initial_users():
    """Create initial users"""
    check_db_is_up()

    sanitized_print(f"Creating users")
    with get_session_with_context() as session:
        for user_dict in users_to_create:
            user_dict["password"] = get_password_hash(
                environ["AIRT_SERVICE_SUPER_USER_PASSWORD"]
            )
            try:
                user = session.exec(
                    select(User).where(User.username == user_dict["username"])
                ).one()
                user.subscription_type = user_dict["subscription_type"]
            except NoResultFound:
                user = User(**user_dict)
            session.add(user)
            session.commit()
    sanitized_print(f"Users created")
